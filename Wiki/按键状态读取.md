# 按键状态读取

## 随机访问某个IO

现在有这么个需求：按顺序依次把`P00, P10, P20, P30`, `P01, P11, P21, P31`...这些`IO`口拉高，程序应该怎么写呢？

对于`51`单片机，`sfr`寄存器不能间接寻址，因此`P0, P1, P2, P3`不可以通过指针访问，只能直接这么写：

```c
// P0 = P1 = P2 = P3 = 0x00;
for(i=0; i<8; i++){
    P0 |= 1 << i;
    P1 |= 1 << i;
    P2 |= 1 << i;
    P3 |= 1 << i;
}
```

这很不优雅，当涉及大量类似操作的时候，会搞出来很多很多重复代码。我们需要的应该是完全`loop`的实现：

```c
// P0 = P1 = P2 = P3 = 0x00;
for(i=0; i<8; i++){
    for(j=0; j<4; j++){
    	P##j##i |= 1 << i;	// 伪代码
    }
}
```

### 使用字符串方式

为了实现运行时的`IO`检查，把一个`IO`记录为`"P30"`，然后用函数分析这个字符串来操作`IO`即可。

```c
#define     SET_BIT(a,b)                            ((a) |= (1 << (b)))
#define     CLEAR_BIT(a,b)                          ((a) &= ~(1 << (b)))
static void GPIO_WriteBit(u8 *GPIO, bit write_bit){
    if(GPIO[0] != 'P' && GPIO[0] != 'p') {return;}
    switch(GPIO[1]){
        case '0':
            write_bit ? SET_BIT(P0, GPIO[2]-'0') : CLEAR_BIT(P0, GPIO[2]-'0');
            break;
        case '1':
            write_bit ? SET_BIT(P1, GPIO[2]-'0') : CLEAR_BIT(P1, GPIO[2]-'0');
            break;
        case '2':
            write_bit ? SET_BIT(P2, GPIO[2]-'0') : CLEAR_BIT(P2, GPIO[2]-'0');
            break;
        case '3':
            write_bit ? SET_BIT(P3, GPIO[2]-'0') : CLEAR_BIT(P3, GPIO[2]-'0');
            break;
        #ifdef        EN_P4
        case '4':
            write_bit ? SET_BIT(P4, GPIO[2]-'0') : CLEAR_BIT(P4, GPIO[2]-'0');
            break;
        #endif
        #ifdef        EN_P5
        case '5':
            write_bit ? SET_BIT(P5, GPIO[2]-'0') : CLEAR_BIT(P5, GPIO[2]-'0');
            break;
        #endif
        #ifdef        EN_P6
        case '6':
            write_bit ? SET_BIT(P6, GPIO[2]-'0') : CLEAR_BIT(P6, GPIO[2]-'0');
            break;
        #endif
    }
}
```

之后，操作`IO`的代码就好办了：

```
// P0 = P1 = P2 = P3 = 0x00;
char GPIO[3] = "P00";
for(i=0; i<8; i++){
    for(j=0; j<4; j++){
    	GPIO[1] = j + '0';
    	GPIO[2] = i + '0';
    	GPIO_WriteBit(GPIO, 1);
    }
}
```

## 按键状态读取

实现了某个`IO`口的随机访问，那么按键随便连的需求也就实现了。具体操作方式就是遍历`Keys.KeyIO`里面的按键，把每个按键的状态读出来即可。

```c
static keyTriggerType_t singleKeyRead(void){
    u8 i;
    keyTriggerType_t read_data = 0;
    
    for(i=0; i<Keys.KeysNumber; i++){
        // port 1 and 2 are both connected to MCU
        // read sequence as follow: 
        // set port2, reset port1, read port2
        // set port1, reset port2, read port1
        if(Keys.KeyIO[i].IOPort2[0] == 'P' || Keys.KeyIO[i].IOPort2[0] == 'p'){    //Pxx
            GPIO_WriteBit(Keys.KeyIO[i].IOPort2, 1);
            GPIO_WriteBit(Keys.KeyIO[i].IOPort1, 0);
            if(GPIO_ReadBit(Keys.KeyIO[i].IOPort2) == 0x00){            // read port2
                GPIO_WriteBit(Keys.KeyIO[i].IOPort1, 1);
                GPIO_WriteBit(Keys.KeyIO[i].IOPort2, 0);
                if(GPIO_ReadBit(Keys.KeyIO[i].IOPort1) == 0x00){        // read port1
                    SET_BIT(read_data, i);
                }
            }
        }else{    // read port1 only, port2 is connected to GND
            GPIO_WriteBit(Keys.KeyIO[i].IOPort1, 1);
            if(GPIO_ReadBit(Keys.KeyIO[i].IOPort1) == 0x00){
                SET_BIT(read_data, i);
            }
        }
    }
    return read_data;
}
```

说明一下`read_data`的存储方式：

`keyTriggerType_t`定义为`unsigned int`

```c
//数据类型是几位就支持几个按键 定义多了占内存
typedef     unsigned int        keyTriggerType_t;
//最大支持按键数量为keyTriggerType_t的位数即(sizeof(keyTriggerType_t)*8)
#define     MAX_KEY_NUMBER      (sizeof(keyTriggerType_t)<<3)
```

所以`read_data`是一个`16`位变量，程序假设按键数量最多是`16`个，`read_data`的每个位都存储一个按键的状态，对应的设置语句是`SET_BIT(read_data, i)`

这样的遍历查询虽然会稍显拖沓，但是兼容性极好，管它什么矩阵、单线，整组的、零散的，通吃，全扔给库函数吧：

```c
// 注册按键 Port1必须是IO口 Port2是IO口或"GND"
SingleKey[EnumKey_A].IOPort1 = "P36"; SingleKey[EnumKey_A].IOPort2 = "GND";
SingleKey[EnumKey_B].IOPort1 = "P52"; SingleKey[EnumKey_B].IOPort2 = "GND";
SingleKey[EnumKey_C].IOPort1 = "P54"; SingleKey[EnumKey_C].IOPort2 = "GND";
SingleKey[EnumKey_D].IOPort1 = "P53"; SingleKey[EnumKey_D].IOPort2 = "GND";
```

